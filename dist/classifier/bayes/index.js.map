{"version":3,"sources":["../../../src/classifier/bayes/index.js"],"names":["module","exports","options","Naivebayes","STATE_KEYS","fromJson","jsonStr","parsed","JSON","parse","e","Error","classifier","forEach","k","defaultTokenizer","text","rgxPunctuation","sanitized","replace","split","Array","isArray","TypeError","tokenizer","vocabulary","vocabularySize","totalDocuments","docCount","wordCount","wordFrequencyCount","categories","prototype","initializeCategory","categoryName","learn","category","self","tokens","frequencyTable","Object","keys","token","frequencyInText","categorize","maxProbability","Infinity","chosenCategory","probabilities","categoryProbability","value","console","log","map","tokenProbability","probability","toFixed","create","toJson","state","stringify"],"mappings":"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","file":"index.js","sourcesContent":["/*\n    Expose our naive-bayes generator function\n */\nmodule.exports = function (options) {\n    return new Naivebayes(options)\n  }\n  \n  // keys we use to serialize a classifier's state\n  var STATE_KEYS = module.exports.STATE_KEYS = [\n    'categories', 'docCount', 'totalDocuments', 'vocabulary', 'vocabularySize',\n    'wordCount', 'wordFrequencyCount', 'options'\n  ];\n  \n  /**\n   * Initializes a NaiveBayes instance from a JSON state representation.\n   * Use this with classifier.toJson().\n   *\n   * @param  {String} jsonStr   state representation obtained by classifier.toJson()\n   * @return {NaiveBayes}       Classifier\n   */\n  module.exports.fromJson = function (jsonStr) {\n    var parsed;\n    try {\n      parsed = JSON.parse(jsonStr)\n    } catch (e) {\n      throw new Error('Naivebayes.fromJson expects a valid JSON string.')\n    }\n    // init a new classifier\n    var classifier = new Naivebayes(parsed.options)\n  \n    // override the classifier's state\n    STATE_KEYS.forEach(function (k) {\n      if (!parsed[k]) {\n        throw new Error('Naivebayes.fromJson: JSON string is missing an expected property: `'+k+'`.')\n      }\n      classifier[k] = parsed[k]\n    })\n  \n    return classifier\n  }\n  \n  /**\n   * Given an input string, tokenize it into an array of word tokens.\n   * This is the default tokenization function used if user does not provide one in `options`.\n   *\n   * @param  {String} text\n   * @return {Array}\n   */\n  var defaultTokenizer = function (text) {\n    //remove punctuation from text - remove anything that isn't a word char or a space\n    var rgxPunctuation = /[^(a-zA-ZA-Яa-я0-9_)+\\s]/g\n  \n    var sanitized = text.replace(rgxPunctuation, ' ')\n  \n    return sanitized.split(/\\s+/)\n  }\n  \n  /**\n   * Naive-Bayes Classifier\n   *\n   * This is a naive-bayes classifier that uses Laplace Smoothing.\n   *\n   * Takes an (optional) options object containing:\n   *   - `tokenizer`  => custom tokenization function\n   *\n   */\n  function Naivebayes (options) {\n    // set options object\n    this.options = {}\n    if (typeof options !== 'undefined') {\n      if (!options || typeof options !== 'object' || Array.isArray(options)) {\n        throw TypeError('NaiveBayes got invalid `options`: `' + options + '`. Pass in an object.')\n      }\n      this.options = options\n    }\n  \n    this.tokenizer = this.options.tokenizer || defaultTokenizer\n  \n    //initialize our vocabulary and its size\n    this.vocabulary = {}\n    this.vocabularySize = 0\n  \n    //number of documents we have learned from\n    this.totalDocuments = 0\n  \n    //document frequency table for each of our categories\n    //=> for each category, how often were documents mapped to it\n    this.docCount = {}\n  \n    //for each category, how many words total were mapped to it\n    this.wordCount = {}\n  \n    //word frequency table for each category\n    //=> for each category, how frequent was a given word mapped to it\n    this.wordFrequencyCount = {}\n  \n    //hashmap of our category names\n    this.categories = {}\n  }\n  \n  /**\n   * Initialize each of our data structure entries for this new category\n   *\n   * @param  {String} categoryName\n   */\n  Naivebayes.prototype.initializeCategory = function (categoryName) {\n    if (!this.categories[categoryName]) {\n      this.docCount[categoryName] = 0\n      this.wordCount[categoryName] = 0\n      this.wordFrequencyCount[categoryName] = {}\n      this.categories[categoryName] = true\n    }\n    return this\n  }\n  \n  /**\n   * train our naive-bayes classifier by telling it what `category`\n   * the `text` corresponds to.\n   *\n   * @param  {String} text\n   * @param  {String} class\n   */\n  Naivebayes.prototype.learn = function (text, category) {\n    var self = this\n  \n    //initialize category data structures if we've never seen this category\n    self.initializeCategory(category)\n  \n    //update our count of how many documents mapped to this category\n    self.docCount[category]++\n  \n    //update the total number of documents we have learned from\n    self.totalDocuments++\n  \n    //normalize the text into a word array\n    var tokens = self.tokenizer(text)\n  \n    //get a frequency count for each token in the text\n    var frequencyTable = self.frequencyTable(tokens)\n  \n    /*\n        Update our vocabulary and our word frequency count for this category\n     */\n  \n    Object\n    .keys(frequencyTable)\n    .forEach(function (token) {\n      //add this word to our vocabulary if not already existing\n      if (!self.vocabulary[token]) {\n        self.vocabulary[token] = true\n        self.vocabularySize++\n      }\n  \n      var frequencyInText = frequencyTable[token]\n  \n      //update the frequency information for this word in this category\n      if (!self.wordFrequencyCount[category][token])\n        self.wordFrequencyCount[category][token] = frequencyInText\n      else\n        self.wordFrequencyCount[category][token] += frequencyInText\n  \n      //update the count of all words we have seen mapped to this category\n      self.wordCount[category] += frequencyInText\n    })\n  \n    return self\n  }\n  \n  /**\n   * Determine what category `text` belongs to.\n   *\n   * @param  {String} text\n   * @return {String} category\n   */\n  Naivebayes.prototype.categorize = function (text) {\n    var self = this\n      , maxProbability = -Infinity\n      , chosenCategory = null\n  \n    var probabilities = self.probabilities(text)\n  \n    //iterate thru our categories to find the one with max probability for this text\n    probabilities\n      .forEach(function (categoryProbability) {\n        if (categoryProbability.value > maxProbability) {\n          maxProbability = categoryProbability.value\n          chosenCategory = categoryProbability.category\n        }\n        console.log(categoryProbability.value)\n      })\n  \n    return chosenCategory;\n  }\n  \n  /**\n   * Determine category probabilities for `text`.\n   *\n   * @param  {String} text\n   * @return {Array} probabilities\n   */\n  Naivebayes.prototype.probabilities = function(text) {\n    var self = this;\n  \n    var tokens = self.tokenizer(text)\n    var frequencyTable = self.frequencyTable(tokens)\n  \n    //iterate thru our categories to calculate the probability for this text\n    return Object\n    .keys(self.categories)\n    .map(function (category) {\n  \n      //start by calculating the overall probability of this category\n      //=>  out of all documents we've ever looked at, how many were\n      //    mapped to this category\n      var categoryProbability = self.docCount[category] / self.totalDocuments\n  \n      //take the log to avoid underflow\n      // var logProbability = Math.log(categoryProbability)\n      \n  \n      //now determine P( w | c ) for each word `w` in the text\n      Object\n      .keys(frequencyTable)\n      .forEach(function (token) {\n        var frequencyInText = frequencyTable[token]\n        var tokenProbability = self.tokenProbability(token, category)\n        //determine the log of the P( w | c ) for this word\n        categoryProbability += frequencyInText * tokenProbability\n      })\n  \n      return {\n        category: category,\n        probability: categoryProbability.toFixed(2),\n      }\n    })\n  }\n  \n  /**\n   * Calculate probability that a `token` belongs to a `category`\n   *\n   * @param  {String} token\n   * @param  {String} category\n   * @return {Number} probability\n   */\n  Naivebayes.prototype.tokenProbability = function (token, category) {\n    //how many times this word has occurred in documents mapped to this category\n    var wordFrequencyCount = this.wordFrequencyCount[category][token] || 0\n  \n    //what is the count of all words that have ever been mapped to this category\n    var wordCount = this.wordCount[category]\n  \n    //use laplace Add-1 Smoothing equation\n    return ( wordFrequencyCount + 1 ) / ( wordCount + this.vocabularySize )\n  }\n  \n  /**\n   * Build a frequency hashmap where\n   * - the keys are the entries in `tokens`\n   * - the values are the frequency of each entry in `tokens`\n   *\n   * @param  {Array} tokens  Normalized word array\n   * @return {Object}\n   */\n  Naivebayes.prototype.frequencyTable = function (tokens) {\n    var frequencyTable = Object.create(null)\n  \n    tokens.forEach(function (token) {\n      if (!frequencyTable[token])\n        frequencyTable[token] = 1\n      else\n        frequencyTable[token]++\n    })\n  \n    return frequencyTable\n  }\n  \n  /**\n   * Dump the classifier's state as a JSON string.\n   * @return {String} Representation of the classifier.\n   */\n  Naivebayes.prototype.toJson = function () {\n    var state = {}\n    var self = this\n    STATE_KEYS.forEach(function (k) {\n      state[k] = self[k]\n    })\n  \n    var jsonStr = JSON.stringify(state)\n  \n    return jsonStr\n  }\n  \n  \n  "]}